#!/usr/bin/perl
#
# Connect to a host in a particular datacenter via ssh using "rterm"
#
# $Id$

use Getopt::Long;
use Pod::Usage;
use Socket;

# All of our datacenters
# Now use DS3 to ita5 instead of direct connect to dc1
#$dc1 = 'dc1.itasoftware.com';
$dc1 = 'ita5login.internal.itasoftware.com';
#$bill = 'zrh.itasoftware.com';
#$atl = 'pot.itasoftware.com';
$wal = 'mky.itasoftware.com';
$hq = 'hq.itasoftware.com';
$med = 'dc5.itasoftware.com';
$home = 'mail.ajs.com';
$vmware = 'asherman@ssh1-vmc.engx.vmware.com';

$default = $med;

our @direct = qw(10.5. 192.168.);
our $is_direct = sub {
	my $ip = shift;
	return grep {$ip =~ /^\Q$_\E/} @direct;
};
# What hostnames (or hostname prefixes) live in what datacetners
our %locations = (
	# Map a hostname prefix like "ita1" to a datacenter
	ita1 => $dc1,
	ita2 => $wal,
	#ita3 => $atl,
	ita4 => $hq,
	ita5 => $med,

	'eng.vmware.com' => $vmware,

	# Here we use "map" to create a large number of mappings at once
	# Add your prefixes (e.g. customer abbreviations) to the appropriate
	# datacenter's list)
	( map {($_ => $dc1)} qw(dc1 cen tni acv3 acv4 mix co aa ac as1 as2
				gal tnirtest tnitest txt1 txt2
				orb1 avs1 avn awa lbg1) ),
	( map {($_ => $wal)} qw(acv1 wdw) ),
	( map {($_ => $hq )} qw(cam test qa) ),
	( map {($_ => $med )} qw(beta txt3 nlg2 nlg3 acv2 az1 orb5
				 avs5 aatest hyd1 th1 tal exp1
				 ual sbr th qres as3 as4 ops hyd) ),

	# Hosts with no prefix
	( map {("_$_" => $wal)} qw(kms hen netapp shelf hog mom tim fox pah
				   mac smk mud ant cub netscreen wsw wsb
				   sue mky cia fbi dog flo liz mon owl) ),
	# ( map {("_$_" => $atl)} qw(pot top lag war raw) ),
	( map {("_$_" => $hq)}  qw(rho lon london dre bug mta bah who pps put
				   gon dns foo muk zah fah sah
				   ick val bwi oldbug newmta pia
				   bfd hfd fon dfw hsv mia ffb) ),

	# Personal
	( map {("_$_" => $home)} qw(b5 markab master) )

);

our $verbose = 0;
our $debug = 0;
our $quiet = 0;

	# Culled from ITA::SysUtils
	Getopt::Long::Configure('auto_abbrev','bundling');
	GetOptions(
		   'h|?|help' => sub {pod2usage(-verbose => 0)},
		   'man' => sub {pod2usage(-verbose => 2)},
		   'v|verbose' => sub {$::verbose=1;$::quiet=0},
		   'd|debug' => sub {$::verbose=1;$::debug=1;$::quiet=0},
		   'q|quiet' => sub {$::verbose=0;$::debug=0;$::quiet=1},
		   @_
		  ) or pod2usage(-verbose => 0);
	sub verbage (@) {
		return unless $::verbose;
		my $msg = join ' ', @_;
		$msg =~ s/\z/\n/ unless $msg =~ /\n\z/;
		print STDERR $msg;
	}
	# Given a CODE ref and a number of seconds, execute the
	# code ref for up to the given time. Returns the return value of
	# the code ref (if any). $@ will be set if a timeout occured.
	sub timeout (&$;@) {
	  my $cmd = shift;
	  my $sec = shift;
	  # Short-circut if no timeout is specified
	  return &{$cmd}(@_) unless defined($sec) && int($sec);
	  my @result;
	  my $result;
	  my $wa = wantarray();
	  my $good = sub {$wa?@result:$result};
	  my $bad  = sub {$wa?():undef};
	  my $to   = sub {die 'timeout'};
	  my $doit = sub {$SIG{ALRM}=$to;alarm($sec);eval{&{$cmd}(@_)};};
	  if ($wa) {
	    @result = &$doit(@_); alarm(0);
	  } else {
	    $result = &$doit(@_); alarm(0);
	  }
	  alarm(0);
	  $SIG{ALRM} = 'DEFAULT';
	  if ($@) {
	    if ($@=~/timeout/) {
	      # A timeout occured
	      return &$bad;
	    } else {
	      # There was another error, propagate
	      croak($@);
	    }
	  } else {
	    # Return the result
	    return &$good;
	  }
	}




foreach my $host (@ARGV) {
	verbage("Connecting to $host");
	my $ip = timeout {gethostbyname $host} 5;
	if ($ip && $is_direct->(inet_ntoa($ip))) {
		exec "rterm $host" or die "Cannot exec rterm: $!";
	} elsif ($host =~ /\.(.*)/ and defined($locations{$1})) {
		my $domain = $1;
		if (defined($locations{$domain})) {
			hop($locations{$domain}, $host);
		}
	} elsif ($host =~ /^([a-z]{2,8})(?:(\d{1,2})(?:([a-z]{2,6}\d{1,2}))?)?$/) {
		my $farm = $1;
		my $bubble = $2;
		my $target = $3;
		if (defined $locations{$farm}) {
			hop($locations{$farm},$host);
		} elsif (defined $locations{"$farm$bubble"}) {
			hop($locations{"$farm$bubble"},$host);
		} elsif (defined $locations{"_$farm"}) {
			hop($locations{"_$farm"}, $host);
		} else {
			warn "Unknown DC for farm=$farm bubble=$bubble host=$target\n" unless $quiet;
			warn "Will try using $default\n" unless $quiet;
			hop($default, $host);
		}
	}
}

sub hop {
	my $user = getlogin() || $ENV{LOGNAME} || $ENV{USER} || 'ajs';
	my $host1 = shift;
	my $host2 = shift;
	if ($host1 =~ s/^(.*)\@//) {
		$user = $1;
	}
	verbage("Connecting to $host2 via $host1");
	die "Would exec 'rterm $host1 $user ssh -tXYA -o StrictHostKeyChecking=no $host2'\n" if $debug;
	exec "rterm $host1 $user ssh -tXA $host2" or die "Cannot exec rterm: $!";
}

__END__

=head1 NAME

rdc - Given a hostname, log into that box, regardless of what dc it's in

=head1 SYNOPSIS

  rdc [--verbose] [--debug] <host>

=head1 DESCRIPTION

Takes a hostname, and tries to use the C<rterm> program to log into it
using two ssh commands (one to the gateway/login server and one to the
target machine).

=head1 AUTHOR

Writtin by ITA Software Inc., 2003

=head1 VERSION

 $Id$

=cut

